number: 21258
title: 'fix(stages): clear ETL collectors on HeaderStage error paths'
state: open
author: joshieDo
head: fix/header-stage-etl-cleanup
base: main
labels: []
created_at: 2026-01-21T15:31:02Z
updated_at: 2026-01-21T15:31:10Z
additions: 6
deletions: 0
is_draft: true
files:
- path: crates/stages/stages/src/stages/headers.rs
  additions: 6
  deletions: 0
body: |-
  ## Problem

  When `DetachedHead` errors occur during header sync, the `hash_collector` and `header_collector` ETL buffers are not cleared. Since headers are downloaded in reverse order (from sync target toward local head), the error is only detected when reaching headers near the local headâ€”by which point most headers have already been collected.

  The Pipeline handles `DetachedHead` by triggering an unwind (typically 3 blocks via `BEACON_CONSENSUS_REORG_UNWIND_DEPTH`) and retrying. On retry, the same headers are downloaded again and inserted into the already-populated collectors. The ETL `Collector::insert` does not deduplicate, so duplicate entries accumulate.

  When `write_headers` iterates over the collector, the static file writer's `check_next_block_number` detects non-sequential block numbers and returns `UnexpectedStaticFileBlockNumber`, causing sync failure.

  ## Root Cause

  Asymmetric cleanup between success and error paths:
  - **Success path**: Collectors are cleared in `execute` after writing
  - **Error paths**: `sync_gap` is reset to `None` but collectors remain populated

  ## Fix

  Clear both collectors and reset `is_etl_ready` whenever `sync_gap` is invalidated:

  1. **DetachedHead error path** - after `self.sync_gap = None`
  2. **unwind method** - after `self.sync_gap.take()`

  This ensures consistent state for retry attempts.
