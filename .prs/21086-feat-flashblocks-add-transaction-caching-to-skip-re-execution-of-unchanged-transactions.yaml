number: 21086
title: 'feat(flashblocks): add transaction caching to skip re-execution of unchanged transactions'
state: open
author: teddyknox
head: teddyknox/state-caching
base: main
labels: []
created_at: 2026-01-14T23:29:50Z
updated_at: 2026-01-14T23:30:18Z
additions: 2741
deletions: 53
is_draft: false
files:
- path: Cargo.lock
  additions: 1
  deletions: 0
- path: crates/optimism/flashblocks/Cargo.toml
  additions: 2
  deletions: 1
- path: crates/optimism/flashblocks/docs/client-side-upstream-scope.md
  additions: 317
  deletions: 0
- path: crates/optimism/flashblocks/src/cache.rs
  additions: 424
  deletions: 19
- path: crates/optimism/flashblocks/src/lib.rs
  additions: 12
  deletions: 1
- path: crates/optimism/flashblocks/src/pending_state.rs
  additions: 148
  deletions: 0
- path: crates/optimism/flashblocks/src/service.rs
  additions: 123
  deletions: 12
- path: crates/optimism/flashblocks/src/tx_cache.rs
  additions: 297
  deletions: 0
- path: crates/optimism/flashblocks/src/validation.rs
  additions: 548
  deletions: 0
- path: crates/optimism/flashblocks/src/worker.rs
  additions: 148
  deletions: 20
- path: crates/optimism/flashblocks/tests/it/harness.rs
  additions: 439
  deletions: 0
- path: crates/optimism/flashblocks/tests/it/main.rs
  additions: 2
  deletions: 0
- path: crates/optimism/flashblocks/tests/it/service.rs
  additions: 280
  deletions: 0
body: "## Summary\r\n\r\nAdd cumulative state caching to avoid re-executing unchanged transactions when new flashblocks arrive.\r\n\r\nPart of the [speculative flashblock building design](https://www.notion.so/oplabs/Flashblocks-Upstreaming-node-reth-features-2e8f153ee162805eaaa5f067fe3440a3?source=copy_link). Builds on [PR 3](https://github.com/op-rs/op-reth/pull/592), and will be a cleaner diff once that merges.\r\n\r\n## Motivation\r\n\r\nWhen a new flashblock arrives, the builder re-executes all transactions from all flashblocks in the sequence. For a block with 10 flashblocks of 50 transactions each, this means 2,750 total executions instead of 500.\r\n\r\nBy caching the cumulative state after execution, we can resume from cached state when the incoming transaction list is a continuation of what was previously executed.\r\n\r\n## Changes\r\n\r\n**`tx_cache.rs`** (new)\r\n- `TransactionCache<N>` stores:\r\n  - Block number the cache is valid for\r\n  - Ordered list of executed transaction hashes\r\n  - Cumulative `BundleState` after all cached transactions\r\n  - Receipts for all cached transactions\r\n- `get_resumable_state()` - Returns cached bundle/receipts/skip_count if incoming transactions have matching prefix\r\n- `matching_prefix_len()` - Computes overlap between cached and incoming transaction lists\r\n- Cache cleared on block change or explicit `clear()`\r\n\r\n**`worker.rs`**\r\n- Accept optional `&mut TransactionCache<N>` in `execute()`\r\n- Check cache for resumable state (canonical mode only)\r\n- Use `with_bundle_prestate()` to restore cached state (same mechanism as speculative execution)\r\n- Skip already-executed transactions, combine cached receipts with new receipts\r\n- Update cache after successful execution\r\n\r\n**`service.rs`**\r\n- Add `tx_cache: TransactionCache<N>` field\r\n- Transfer cache ownership to spawned build tasks via `std::mem::take()`\r\n- Return cache with build results, restore after task completion\r\n- Clear cache on reorg, catch-up, or depth limit exceeded\r\n\r\n## Testing\r\n\r\nUnit tests in `tx_cache.rs`:\r\n- Block validation and clearing\r\n- Prefix matching with exact match, continuation, partial match, no match\r\n- `get_resumable_state()` behavior with wrong block, empty cache, partial prefix\r\n"
