#!/usr/bin/env cargo +nightly -Zscript
---
[dependencies]
clap = {version="4", features = ["derive"]}
indexmap = "2.5.0"
pathdiff = "0.2"
regex = "1.10.6"
---
use clap::Parser;
use indexmap::IndexMap;
use regex::Regex;
use std::fs::{self, File};
use std::io::{self, Write};
use std::iter::once;
use std::path::{Path, PathBuf};
use std::process;
use std::process::{Command, Stdio};
use std::str;

const SECTION_START: &str = "<!-- CLI_REFERENCE START -->";
const SECTION_END: &str = "<!-- CLI_REFERENCE END -->";
const README: &str = r#"
# CLI Reference

<!-- Generated by scripts/gen_output/help.py -->

Automatically-generated CLI reference from `--help` output.

{{#include ./SUMMARY.md}}
"#;

/// Generate markdown files from help output of commands
#[derive(Parser, Debug)]
#[command(about, long_about = None)]
struct Args {
    /// Root directory
    #[arg(long, default_value_t = String::from("."))]
    root_dir: String,

    /// Indentation for the root SUMMARY.md file
    #[arg(long, default_value_t = 2)]
    root_indentation: usize,

    /// Output directory
    #[arg(long)]
    out_dir: PathBuf,

    /// Whether to add a README.md file
    #[arg(long)]
    readme: bool,

    /// Whether to update the root SUMMARY.md file
    #[arg(long)]
    root_summary: bool,

    /// Print verbose output
    #[arg(short, long)]
    verbose: bool,

    /// Command to generate markdown for.
    command: PathBuf,
}

fn write_file(file_path: &Path, content: &str) -> io::Result<()> {
    let content = content
        .lines()
        .map(|line| line.trim_end())
        .collect::<Vec<_>>()
        .join("\n");
    let mut file = File::create(file_path)?;
    file.write_all(content.as_bytes())?;
    Ok(())
}

fn main() -> io::Result<()> {
    let args = Args::parse();
    let out_dir = args.out_dir;
    fs::create_dir_all(&out_dir)?;

    let command_name = args
        .command
        .file_name()
        .expect("Expect valid command")
        .to_string_lossy()
        .to_string();
    let mut todo_iter: Vec<Vec<String>> = vec![vec![command_name]];
    let mut output = IndexMap::new(); // keep the order in which entries are added

    //Iterate over all commands and their subcommands.
    while let Some(cmd) = todo_iter.pop() {
        let (new_subcmds, stdout) = get_entry(&args.command, cmd.clone())?;
        if args.verbose && !new_subcmds.is_empty() {
            println!(
                "Found subcommands for \"{}\": {:?}",
                cmd.join(" "),
                new_subcmds
            );
        }
        // Add new subcommands to todo_iter (so that they are processed in the correct order).
        for subcmd in new_subcmds.into_iter().rev() {
            let new_cmd: Vec<_> = cmd.iter().cloned().chain(once(subcmd)).collect();
            todo_iter.push(new_cmd);
        }
        output.insert(cmd, stdout);
    }

    // Generate markdown files.
    for (cmd, stdout) in &output {
        cmd_markdown(&out_dir, cmd, stdout)?;
    }

    // Generate SUMMARY.md
    let summary: String = output
        .keys()
        .map(|cmd| cmd_summary(None, cmd, 0))
        .chain(once("\n\n".to_string()))
        .collect();

    write_file(&out_dir.clone().join("SUMMARY.md"), &summary)?;

    // Generate README.md.
    if args.readme {
        let path = &out_dir.join("README.md");
        if args.verbose {
            println!("Writing README.md to \"{}\"", path.to_string_lossy());
        }
        write_file(path, README)?;
    }

    if args.root_summary {
        // Generate
        let root_summary: String = output
            .keys()
            .map(|cmd| {
                let root_path = pathdiff::diff_paths(&out_dir, &args.root_dir);
                cmd_summary(root_path, cmd, args.root_indentation)
            })
            .collect();

        let path = Path::new(args.root_dir.as_str());
        if args.verbose {
            println!("Updating root summary in \"{}\"", path.to_string_lossy());
        }
        update_root_summary(path, &root_summary)?;
    }

    Ok(())
}

/// Returns the subcommands and help output for a command.
fn get_entry(cmd: &PathBuf, subcmd: Vec<String>) -> io::Result<(Vec<String>, String)> {
    let output = Command::new(cmd)
        .args(&subcmd[1..])
        .arg("--help")
        .env("NO_COLOR", "1")
        .env("COLUMNS", "100")
        .env("LINES", "10000")
        .stdout(Stdio::piped())
        .output()?;

    if !output.status.success() {
        let stderr = str::from_utf8(&output.stderr).unwrap_or("Failed to parse stderr as UTF-8");
        return Err(io::Error::new(
            io::ErrorKind::Other,
            format!(
                "Command \"{} {}\" failed:\n{}",
                cmd.to_string_lossy(),
                subcmd.join(" "),
                stderr
            ),
        ));
    }

    let stdout = str::from_utf8(&output.stdout)
        .map_err(|e| io::Error::new(io::ErrorKind::InvalidData, e))?
        .to_string();

    // Parse subcommands from the help output
    let subcmds = parse_sub_commands(&stdout);

    Ok((subcmds, stdout))
}

/// Returns a list of subcommands from the help output of a command.
fn parse_sub_commands(s: &str) -> Vec<String> {
    s.split("Commands:")
        .nth(1) // Get the part after "Commands:"
        .map(|commands_section| {
            commands_section
                .lines()
                .take_while(|line| !line.starts_with("Options:") && !line.starts_with("Arguments:"))
                .filter_map(|line| line.split_whitespace().next()) // take subcommand name
                .filter(|&cmd| cmd != "help")
                .map(String::from)
                .collect()
        })
        .unwrap_or_default() // Return an empty Vec if "Commands:" was not found
}

/// Writes the markdown for a command to out_dir.
fn cmd_markdown(out_dir: &Path, cmd: &[String], stdout: &str) -> io::Result<()> {
    let mut out = format!("# {}\n\n", cmd.join(" "));
    out.push_str(&help_markdown(cmd, stdout));

    let out_path = out_dir.join(cmd.join("/"));
    fs::create_dir_all(out_path.parent().unwrap())?;
    write_file(&out_path.with_extension("md"), &out)?;

    Ok(())
}

/// Returns the markdown for a command's help output.
fn help_markdown(cmd: &[String], stdout: &str) -> String {
    let (description, s) = parse_description(stdout);
    format!(
        "{}\n\n```bash\n$ {} --help\n{}\n```",
        description,
        cmd.join(" "),
        preprocess_help(s.trim())
    )
}

/// Splits the help output into a description and the rest.
fn parse_description(s: &str) -> (&str, &str) {
    match s.find("Usage:") {
        Some(idx) => {
            let description = s[..idx].trim().lines().next().unwrap_or("");
            (description, &s[idx..])
        }
        None => ("", s),
    }
}

/// Returns the summary for a command and its subcommands.
fn cmd_summary(md_root: Option<PathBuf>, cmd: &[String], indent: usize) -> String {
    let cmd_s = cmd.join(" ");
    let cmd_path = cmd.join("/");
    let full_cmd_path = match md_root {
        None => cmd_path,
        Some(md_root) => format!("{}/{}", md_root.to_string_lossy(), cmd_path),
    };
    let indent_string = " ".repeat(indent + (cmd.len() - 1) * 2);
    format!("{}- [`{}`](./{}.md)\n", indent_string, cmd_s, full_cmd_path)
}

/// Replaces the CLI_REFERENCE section in the root SUMMARY.md file.
fn update_root_summary(root_dir: &Path, root_summary: &str) -> io::Result<()> {
    let summary_file = root_dir.join("SUMMARY.md");
    let original_summary_content = fs::read_to_string(&summary_file)?;

    let section_re = Regex::new(&format!(r"(?s)\s*{}.*?{}", SECTION_START, SECTION_END)).unwrap();
    if !section_re.is_match(&original_summary_content) {
        eprintln!(
            "Could not find CLI_REFERENCE section in {}. Please add the following section to the file:\n{}\n... CLI Reference goes here ...\n\n{}",
            summary_file.display(),
            SECTION_START,
            SECTION_END
        );
        process::exit(1);
    }

    let section_re = Regex::new(&format!(r".*{}", SECTION_END)).unwrap();
    let last_line = section_re
        .find(&original_summary_content)
        .map(|m| m.as_str().to_string())
        .expect("Could not extract last line of CLI_REFERENCE section");

    let root_summary_s = root_summary.trim_end().replace("\n\n", "\n");
    let replace_with = format!(" {}\n{}\n{}", SECTION_START, root_summary_s, last_line);

    let section_re = Regex::new(&format!(r"(?s)\s*{}.*?{}", SECTION_START, SECTION_END)).unwrap();

    let new_root_summary = section_re
        .replace(&original_summary_content, replace_with.as_str())
        .to_string();

    let mut root_summary_file = File::create(&summary_file)?;
    root_summary_file.write_all(new_root_summary.as_bytes())
}

/// Preprocesses the help output of a command.
fn preprocess_help(s: &str) -> String {
    let patterns = [
        // Remove the user-specific paths.
        (r"default: /.*/reth", "default: <CACHE_DIR>"),
        // Remove the commit SHA and target architecture triple or fourth
        //  rustup available targets:
        //    aarch64-apple-darwin
        //    x86_64-unknown-linux-gnu
        //    x86_64-pc-windows-gnu
        (
            r"default: reth/.*-[0-9A-Fa-f]{6,10}/([_\w]+)-(\w+)-(\w+)(-\w+)?",
            "default: reth/<VERSION>-<SHA>/<ARCH>",
        ),
        // Remove the OS
        (r"default: reth/.*/\w+", "default: reth/<VERSION>/<OS>"),
        // Remove rpc.max-tracing-requests default value
        (
            r"(rpc.max-tracing-requests <COUNT>\n.*\n.*\n.*)\[default: \d+\]",
            r"$1[default: <NUM CPU CORES-2>]",
        ),
    ];

    let mut result = s.to_owned();
    for (pattern, replacement) in &patterns {
        let re = Regex::new(pattern).expect("Failed to compile regex pattern");
        result = re.replace_all(&result, *replacement).into_owned();
    }

    result
}
