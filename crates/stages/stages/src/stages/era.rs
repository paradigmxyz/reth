use crate::{StageCheckpoint, StageId};
use alloy_primitives::{BlockHash, BlockNumber};
use reqwest::{Client, Url};
use reth_config::config::EtlConfig;
use reth_db_api::{table::Value, transaction::DbTxMut};
use reth_era_downloader::{read_dir, EraClient, EraStream, EraStreamConfig};
use reth_era_utils as era;
use reth_etl::Collector;
use reth_primitives_traits::{Block, FullBlockBody, FullBlockHeader, NodePrimitives};
use reth_provider::{BlockWriter, DBProvider, NodePrimitivesProvider, StaticFileProviderFactory};
use reth_stages_api::{ExecInput, ExecOutput, Stage, StageError, UnwindInput, UnwindOutput};
use std::path::PathBuf;

/// The [ERA1](https://github.com/eth-clients/e2store-format-specs/blob/main/formats/era1.md)
/// pre-merge history stage.
///
/// Imports block headers and bodies from genesis up to the last pre-merge block. Receipts are
/// generated by execution. Execution is not done in this stage.
#[derive(Debug)]
pub struct EraStage {
    source: Option<ImportSource>,
    hash_collector: Collector<BlockHash, BlockNumber>,
}

/// Describes where to get the era files from.
#[derive(Debug, Clone)]
pub enum ImportSource {
    /// Remote HTTP accessible host.
    Url(Url, PathBuf),
    /// Local directory.
    Path(PathBuf),
}

impl EraStage {
    /// Creates a new [`EraStage`].
    pub fn new(source: Option<ImportSource>, etl_config: EtlConfig) -> Self {
        Self { source, hash_collector: Collector::new(etl_config.file_size, etl_config.dir) }
    }
}

impl<Provider, B, BB, BH> Stage<Provider> for EraStage
where
    B: Block<Header=BH, Body=BB>,
    BH: FullBlockHeader + Value,
    BB: FullBlockBody<
        Transaction=<<Provider as NodePrimitivesProvider>::Primitives as NodePrimitives>::SignedTx,
        OmmerHeader=BH,
    >,
    Provider: DBProvider<Tx: DbTxMut> + StaticFileProviderFactory + BlockWriter<Block=B>,
    <Provider as NodePrimitivesProvider>::Primitives:
    NodePrimitives<BlockHeader=BH, BlockBody=BB>,
{
    fn id(&self) -> StageId {
        StageId::Era
    }

    fn execute(&mut self, provider: &Provider, input: ExecInput) -> Result<ExecOutput, StageError> {
        match self.source.clone() {
            Some(source) => match source {
                ImportSource::Path(path) => {
                    let mut stream = read_dir(path).map_err(|e| StageError::Fatal(e.into()))?;

                    era::import(&mut stream, provider, &mut self.hash_collector)
                }
                ImportSource::Url(url, era_dir) => {
                    let folder = era_dir.into_boxed_path();
                    let client = EraClient::new(Client::new(), url, folder);
                    let mut stream = EraStream::new(client, EraStreamConfig::default());

                    era::import(&mut stream, provider, &mut self.hash_collector)
                }
            }
                .map(|height| ExecOutput::done(StageCheckpoint::new(height)))
                .map_err(|e| StageError::Recoverable(e.into())),
            None => Ok(ExecOutput::done(StageCheckpoint::new(input.checkpoint.map(|v| v.block_number).unwrap_or(0))))
        }
    }

    fn unwind(
        &mut self,
        _provider: &Provider,
        _input: UnwindInput,
    ) -> Result<UnwindOutput, StageError> {
        todo!()
    }
}
