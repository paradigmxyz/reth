use crate::{stages, StageCheckpoint, StageId};
use alloy_primitives::{BlockHash, BlockNumber};
use futures_util::{Stream, StreamExt};
use reqwest::{Client, Url};
use reth_config::config::EtlConfig;
use reth_db_api::{table::Value, tables, transaction::DbTxMut, DbTxUnwindExt};
use reth_era_downloader::{read_dir, EraClient, EraMeta, EraStream, EraStreamConfig};
use reth_era_utils as era;
use reth_etl::Collector;
use reth_primitives_traits::{Block, FullBlockBody, FullBlockHeader, NodePrimitives};
use reth_provider::{
    BlockHashReader, BlockReader, BlockWriter, DBProvider, HeaderProvider, NodePrimitivesProvider,
    StaticFileProviderFactory, StaticFileWriter, StorageLocation,
};
use reth_stages_api::{ExecInput, ExecOutput, Stage, StageError, UnwindInput, UnwindOutput};
use reth_static_file_types::StaticFileSegment;
use reth_storage_errors::ProviderError;
use std::{
    fmt::{Debug, Formatter},
    path::PathBuf,
    task::{ready, Context, Poll},
};

type ThreadSafeEraStream = Box<
    dyn Stream<Item = eyre::Result<Box<dyn EraMeta + Sync + Send + 'static>>>
        + Send
        + Sync
        + 'static
        + Unpin,
>;

/// The [ERA1](https://github.com/eth-clients/e2store-format-specs/blob/main/formats/era1.md)
/// pre-merge history stage.
///
/// Imports block headers and bodies from genesis up to the last pre-merge block. Receipts are
/// generated by execution. Execution is not done in this stage.
pub struct EraStage {
    source: Option<EraImportSource>,
    hash_collector: Collector<BlockHash, BlockNumber>,
    item: Option<Box<dyn EraMeta + Sync + Send + 'static>>,
    stream: Option<ThreadSafeEraStream>,
    last_block_height: Option<BlockNumber>,
}

impl Debug for EraStage {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EraStage")
            .field("source", &self.source)
            .field("hash_collector", &self.hash_collector)
            .field("item", &self.item)
            .field("stream", &"dyn Stream")
            .finish()
    }
}

impl EraStage {
    /// Creates a new [`EraStage`].
    pub fn new(source: Option<EraImportSource>, etl_config: EtlConfig) -> Self {
        Self {
            source,
            item: None,
            stream: None,
            last_block_height: None,
            hash_collector: Collector::new(etl_config.file_size, etl_config.dir),
        }
    }
}

impl<Provider, B, BB, BH> Stage<Provider> for EraStage
where
    B: Block<Header=BH, Body=BB>,
    BH: FullBlockHeader + Value,
    BB: FullBlockBody<
        Transaction=<<Provider as NodePrimitivesProvider>::Primitives as NodePrimitives>::SignedTx,
        OmmerHeader=BH,
    >,
    Provider: DBProvider<Tx: DbTxMut> + StaticFileProviderFactory + BlockWriter<Block=B> + BlockReader<Block=B>,
    <Provider as NodePrimitivesProvider>::Primitives:
    NodePrimitives<BlockHeader=BH, BlockBody=BB>,
{
    fn id(&self) -> StageId {
        StageId::Era
    }

    fn poll_execute_ready(&mut self, cx: &mut Context<'_>, input: ExecInput) -> Poll<Result<(), StageError>> {
        if input.target_reached() || self.item.is_some() {
            return Poll::Ready(Ok(()));
        }

        if self.stream.is_none() {
            if let Some(source) = self.source.clone() {
                match source {
                    EraImportSource::Path(path) => {
                        self.stream.replace({
                            let stream = read_dir(path).map_err(|e| StageError::Fatal(e.into()))?;

                            Box::new(Box::pin(stream
                                .map(|v| v
                                    .map(|v| Box::new(v) as Box<dyn EraMeta + Send + Sync + 'static>))
                            ))
                        });
                    }
                    EraImportSource::Url(url, era_dir) => {
                        let folder = era_dir.into_boxed_path();
                        let _ = reth_fs_util::create_dir_all(&folder);
                        let client = EraClient::new(Client::new(), url, folder);

                        self.stream.replace({
                            let stream = EraStream::new(client, EraStreamConfig::default());

                            Box::new(Box::pin(stream
                                .map(|v| v
                                    .map(|v| Box::new(v) as Box<dyn EraMeta + Send + Sync + 'static>))
                            ))
                        });
                    }
                }
            }
        }
        if let Some(stream) = &mut self.stream {
            if let Some(next) = ready!(stream.poll_next_unpin(cx)).transpose().map_err(|e| StageError::Fatal(e.into()))? {
                self.item.replace(next);
            }
        }

        Poll::Ready(Ok(()))
    }

    fn execute(&mut self, provider: &Provider, input: ExecInput) -> Result<ExecOutput, StageError> {
        let era = self.item.take().ok_or(StageError::MissingDownloadBuffer)?;
        let static_file_provider = provider.static_file_provider();

        // Consistency check of expected headers in static files vs DB is done on provider::sync_gap
        // when poll_execute_ready is polled.
        let last_header_number = static_file_provider
            .get_highest_static_file_block(StaticFileSegment::Headers)
            .unwrap_or_default();

        // Find the latest total difficulty
        let mut td = static_file_provider
            .header_td_by_number(last_header_number)?
            .ok_or(ProviderError::TotalDifficultyNotFound(last_header_number))?;

        // Although headers were downloaded in reverse order, the collector iterates it in ascending
        // order
        let mut writer = static_file_provider.latest_writer(StaticFileSegment::Headers)?;

        let height = era::process(era.as_ref(), &mut writer, provider, &mut self.hash_collector, &mut td, last_header_number..=input.target()).map_err(|e| StageError::Fatal(e.into()))?;

        self.last_block_height.replace(height);

        if !self.hash_collector.is_empty() {
            era::build_index(provider, &mut self.hash_collector)
                .map_err(|e| StageError::Recoverable(e.into()))?;
            self.hash_collector.clear();
        }

        Ok(ExecOutput::done(StageCheckpoint::new(height)))
    }

    fn unwind(
        &mut self,
        provider: &Provider,
        input: UnwindInput,
    ) -> Result<UnwindOutput, StageError> {
        self.hash_collector.clear();
        self.item.take();
        self.last_block_height.take();
        self.stream.take();

        if let Some(source) = &self.source {
            // Bodies
            stages::ensure_consistency(provider, Some(input.unwind_to))?;
            provider.remove_bodies_above(input.unwind_to, StorageLocation::Both)?;

            // Wipe any unprocessed era files in the download temp directory
            if let EraImportSource::Url(_, path) = source {
                if let Ok(dir) = path.read_dir() {
                    for entry in dir.flatten() {
                        let path = entry.path();

                        if path.extension() == Some("era1".as_ref()) {
                            let _ = reth_fs_util::remove_file(path);
                        }
                    }
                }
            }

            // First unwind the db tables, until the unwind_to block number. use the walker to unwind
            // HeaderNumbers based on the index in CanonicalHeaders
            // unwind from the next block number since the unwind_to block is exclusive
            provider
                .tx_ref()
                .unwind_table_by_walker::<tables::CanonicalHeaders, tables::HeaderNumbers>(
                    (input.unwind_to + 1)..,
                )?;
            provider.tx_ref().unwind_table_by_num::<tables::CanonicalHeaders>(input.unwind_to)?;
            provider
                .tx_ref()
                .unwind_table_by_num::<tables::HeaderTerminalDifficulties>(input.unwind_to)?;

            // determine how many headers to unwind from the static files based on the highest block and
            // the unwind_to block
            let static_file_provider = provider.static_file_provider();
            let highest_block = static_file_provider
                .get_highest_static_file_block(StaticFileSegment::Headers)
                .unwrap_or_default();
            let static_file_headers_to_unwind = highest_block - input.unwind_to;
            for block_number in (input.unwind_to + 1)..=highest_block {
                let hash = static_file_provider.block_hash(block_number)?;
                // we have to delete from HeaderNumbers here as well as in the above unwind, since that
                // mapping contains entries for both headers in the db and headers in static files
                //
                // so if we are unwinding past the lowest block in the db, we have to iterate through
                // the HeaderNumbers entries that we'll delete in static files below
                if let Some(header_hash) = hash {
                    provider.tx_ref().delete::<tables::HeaderNumbers>(header_hash, None)?;
                }
            }

            // Now unwind the static files until the unwind_to block number
            let mut writer = static_file_provider.latest_writer(StaticFileSegment::Headers)?;
            writer.prune_headers(static_file_headers_to_unwind)?;
        }

        Ok(UnwindOutput { checkpoint: input.checkpoint.with_block_number(input.unwind_to) })
    }
}

/// Describes where to get the era files from.
#[derive(Debug, Clone)]
pub enum EraImportSource {
    /// Remote HTTP accessible host.
    Url(Url, PathBuf),
    /// Local directory.
    Path(PathBuf),
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::test_utils::{
        stage_test_suite, ExecuteStageTestRunner, StageTestRunner, UnwindStageTestRunner,
    };
    use alloy_primitives::B256;
    use reth_testing_utils::generators::{self, random_header};
    use test_runner::EraTestRunner;

    mod test_runner {
        use super::*;
        use crate::test_utils::{TestRunnerError, TestStageDB};
        use reth_db_api::{
            models::{StoredBlockBodyIndices, StoredBlockOmmers},
            transaction::DbTx,
        };
        use reth_primitives_traits::{SealedBlock, SealedHeader};
        use reth_provider::BlockNumReader;
        use reth_testing_utils::generators::{
            random_block_range, random_signed_tx, BlockRangeParams,
        };
        use std::str::FromStr;
        use tempfile::TempDir;
        use tokio::sync::watch;

        pub(crate) struct EraTestRunner {
            channel: (watch::Sender<B256>, watch::Receiver<B256>),
            db: TestStageDB,
            tempdir: TempDir,
        }

        impl Default for EraTestRunner {
            fn default() -> Self {
                Self {
                    tempdir: TempDir::new().unwrap(),
                    channel: watch::channel(B256::ZERO),
                    db: TestStageDB::default(),
                }
            }
        }

        impl StageTestRunner for EraTestRunner {
            type S = EraStage;

            fn db(&self) -> &TestStageDB {
                &self.db
            }

            fn stage(&self) -> Self::S {
                EraStage::new(
                    Some(EraImportSource::Url(
                        Url::from_str("https://era.ithaca.xyz/era1/").unwrap(),
                        self.tempdir.path().join("era"),
                    )),
                    EtlConfig::default(),
                )
            }
        }

        impl ExecuteStageTestRunner for EraTestRunner {
            type Seed = Vec<SealedBlock<reth_ethereum_primitives::Block>>;

            fn seed_execution(&mut self, input: ExecInput) -> Result<Self::Seed, TestRunnerError> {
                let start = input.checkpoint().block_number;
                let end = input.target();

                let static_file_provider = self.db.factory.static_file_provider();

                let mut rng = generators::rng();

                // Static files do not support gaps in headers, so we need to generate 0 to end
                let blocks = random_block_range(
                    &mut rng,
                    0..=end,
                    BlockRangeParams {
                        parent: Some(B256::ZERO),
                        tx_count: 0..2,
                        ..Default::default()
                    },
                );
                self.db.insert_headers_with_td(blocks.iter().map(|block| block.sealed_header()))?;
                if let Some(progress) = blocks.get(start as usize) {
                    // Insert last progress data
                    {
                        let tx = self.db.factory.provider_rw()?.into_tx();
                        let mut static_file_producer = static_file_provider
                            .get_writer(start, StaticFileSegment::Transactions)?;

                        let body = StoredBlockBodyIndices {
                            first_tx_num: 0,
                            tx_count: progress.transaction_count() as u64,
                        };

                        static_file_producer.set_block_range(0..=progress.number);

                        body.tx_num_range().try_for_each(|tx_num| {
                            let transaction = random_signed_tx(&mut rng);
                            static_file_producer.append_transaction(tx_num, &transaction).map(drop)
                        })?;

                        if body.tx_count != 0 {
                            tx.put::<tables::TransactionBlocks>(
                                body.last_tx_num(),
                                progress.number,
                            )?;
                        }

                        tx.put::<tables::BlockBodyIndices>(progress.number, body)?;

                        if !progress.ommers_hash_is_empty() {
                            tx.put::<tables::BlockOmmers>(
                                progress.number,
                                StoredBlockOmmers { ommers: progress.body().ommers.clone() },
                            )?;
                        }

                        static_file_producer.commit()?;
                        tx.commit()?;
                    }
                }
                Ok(blocks)
            }

            /// Validate stored headers
            fn validate_execution(
                &self,
                input: ExecInput,
                output: Option<ExecOutput>,
            ) -> Result<(), TestRunnerError> {
                let initial_checkpoint = input.checkpoint().block_number;
                match output {
                    Some(output) if output.checkpoint.block_number > initial_checkpoint => {
                        let provider = self.db.factory.provider()?;
                        let mut td = provider
                            .header_td_by_number(initial_checkpoint.saturating_sub(1))?
                            .unwrap_or_default();

                        for block_num in initial_checkpoint..output.checkpoint.block_number {
                            // look up the header hash
                            let hash = provider.block_hash(block_num)?.expect("no header hash");

                            // validate the header number
                            assert_eq!(provider.block_number(hash)?, Some(block_num));

                            // validate the header
                            let header = provider.header_by_number(block_num)?;
                            assert!(header.is_some());
                            let header = SealedHeader::seal_slow(header.unwrap());
                            assert_eq!(header.hash(), hash);

                            // validate the header total difficulty
                            td += header.difficulty;
                            assert_eq!(provider.header_td_by_number(block_num)?, Some(td));
                        }
                    }
                    _ => self.check_no_header_entry_above(initial_checkpoint)?,
                };
                Ok(())
            }

            async fn after_execution(&self, headers: Self::Seed) -> Result<(), TestRunnerError> {
                let tip = if headers.is_empty() {
                    let tip = random_header(&mut generators::rng(), 0, None);
                    self.db.insert_headers(std::iter::once(&tip))?;
                    tip.hash()
                } else {
                    headers.last().unwrap().hash()
                };
                self.send_tip(tip);
                Ok(())
            }
        }

        impl UnwindStageTestRunner for EraTestRunner {
            fn validate_unwind(&self, input: UnwindInput) -> Result<(), TestRunnerError> {
                self.check_no_header_entry_above(input.unwind_to)
            }
        }

        impl EraTestRunner {
            pub(crate) fn check_no_header_entry_above(
                &self,
                block: BlockNumber,
            ) -> Result<(), TestRunnerError> {
                self.db
                    .ensure_no_entry_above_by_value::<tables::HeaderNumbers, _>(block, |val| val)?;
                self.db.ensure_no_entry_above::<tables::CanonicalHeaders, _>(block, |key| key)?;
                self.db.ensure_no_entry_above::<tables::Headers, _>(block, |key| key)?;
                self.db.ensure_no_entry_above::<tables::HeaderTerminalDifficulties, _>(
                    block,
                    |num| num,
                )?;
                Ok(())
            }

            pub(crate) fn send_tip(&self, tip: B256) {
                self.channel.0.send(tip).expect("failed to send tip");
            }
        }
    }

    stage_test_suite!(EraTestRunner, era);
}
