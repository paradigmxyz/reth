use crate::{StageCheckpoint, StageId};
use alloy_primitives::{BlockHash, BlockNumber};
use futures_util::{Stream, StreamExt};
use reqwest::{Client, Url};
use reth_config::config::EtlConfig;
use reth_db_api::{table::Value, transaction::DbTxMut};
use reth_era_downloader::{read_dir, EraClient, EraMeta, EraStream, EraStreamConfig};
use reth_era_utils as era;
use reth_etl::Collector;
use reth_primitives_traits::{Block, FullBlockBody, FullBlockHeader, NodePrimitives};
use reth_provider::{
    BlockWriter, DBProvider, HeaderProvider, NodePrimitivesProvider, StaticFileProviderFactory,
    StaticFileWriter,
};
use reth_stages_api::{ExecInput, ExecOutput, Stage, StageError, UnwindInput, UnwindOutput};
use reth_static_file_types::StaticFileSegment;
use reth_storage_errors::ProviderError;
use std::{
    fmt::{Debug, Formatter},
    path::PathBuf,
    task::{ready, Context, Poll},
};

type GlobalBoxStream = Box<
    dyn Stream<Item = eyre::Result<Box<dyn EraMeta + Sync + Send + 'static>>>
        + Send
        + Sync
        + 'static
        + Unpin,
>;

/// The [ERA1](https://github.com/eth-clients/e2store-format-specs/blob/main/formats/era1.md)
/// pre-merge history stage.
///
/// Imports block headers and bodies from genesis up to the last pre-merge block. Receipts are
/// generated by execution. Execution is not done in this stage.
pub struct EraStage {
    source: Option<ImportSource>,
    hash_collector: Collector<BlockHash, BlockNumber>,
    item: Option<Box<dyn EraMeta + Sync + Send + 'static>>,
    stream: Option<GlobalBoxStream>,
}

impl Debug for EraStage {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("EraStage")
            .field("source", &self.source)
            .field("hash_collector", &self.hash_collector)
            .field("item", &self.item)
            .field("stream", &"dyn Stream")
            .finish()
    }
}

/// Describes where to get the era files from.
#[derive(Debug, Clone)]
pub enum ImportSource {
    /// Remote HTTP accessible host.
    Url(Url, PathBuf),
    /// Local directory.
    Path(PathBuf),
}

impl EraStage {
    /// Creates a new [`EraStage`].
    pub fn new(source: Option<ImportSource>, etl_config: EtlConfig) -> Self {
        Self {
            source,
            item: None,
            stream: None,
            hash_collector: Collector::new(etl_config.file_size, etl_config.dir),
        }
    }
}

impl<Provider, B, BB, BH> Stage<Provider> for EraStage
where
    B: Block<Header=BH, Body=BB>,
    BH: FullBlockHeader + Value,
    BB: FullBlockBody<
        Transaction=<<Provider as NodePrimitivesProvider>::Primitives as NodePrimitives>::SignedTx,
        OmmerHeader=BH,
    >,
    Provider: DBProvider<Tx: DbTxMut> + StaticFileProviderFactory + BlockWriter<Block=B>,
    <Provider as NodePrimitivesProvider>::Primitives:
    NodePrimitives<BlockHeader=BH, BlockBody=BB>,
{
    fn id(&self) -> StageId {
        StageId::Era
    }

    fn poll_execute_ready(&mut self, cx: &mut Context<'_>, _input: ExecInput) -> Poll<Result<(), StageError>> {
        if self.stream.is_none() {
            if let Some(source) = self.source.clone() {
                match source {
                    ImportSource::Path(path) => {
                        self.stream.replace({
                            let stream = read_dir(path).map_err(|e| StageError::Fatal(e.into()))?;

                            Box::new(Box::pin(stream
                                .map(|v| v
                                    .map(|v| Box::new(v) as Box<dyn EraMeta + Send + Sync + 'static>))
                            ))
                        });
                    }
                    ImportSource::Url(url, era_dir) => {
                        let folder = era_dir.into_boxed_path();
                        let client = EraClient::new(Client::new(), url, folder);

                        self.stream.replace({
                            let stream = EraStream::new(client, EraStreamConfig::default());

                            Box::new(Box::pin(stream
                                .map(|v| v
                                    .map(|v| Box::new(v) as Box<dyn EraMeta + Send + Sync + 'static>))
                            ))
                        });
                    }
                }
            }
        }
        if let Some(stream) = &mut self.stream {
            if let Some(next) = ready!(stream.poll_next_unpin(cx)).transpose().map_err(|e| StageError::Fatal(e.into()))? {
                self.item.replace(next);
            }
        }

        Poll::Ready(Ok(()))
    }

    fn execute(&mut self, provider: &Provider, input: ExecInput) -> Result<ExecOutput, StageError> {
        match self.item.take() {
            Some(source) => {
                let static_file_provider = provider.static_file_provider();

                // Consistency check of expected headers in static files vs DB is done on provider::sync_gap
                // when poll_execute_ready is polled.
                let last_header_number = static_file_provider
                    .get_highest_static_file_block(StaticFileSegment::Headers)
                    .unwrap_or_default();

                // Find the latest total difficulty
                let mut td = static_file_provider
                    .header_td_by_number(last_header_number)?
                    .ok_or(ProviderError::TotalDifficultyNotFound(last_header_number))?;

                // Although headers were downloaded in reverse order, the collector iterates it in ascending
                // order
                let mut writer = static_file_provider.latest_writer(StaticFileSegment::Headers)?;

                era::process(source.as_ref(), &mut writer, provider, &mut self.hash_collector, &mut td)
            }
                .map(|height| ExecOutput::done(StageCheckpoint::new(height.unwrap_or_default())))
                .map_err(|e| StageError::Recoverable(e.into())),
            None => Ok(ExecOutput::done(StageCheckpoint::new(input.target())))
        }
    }

    fn unwind(
        &mut self,
        _provider: &Provider,
        input: UnwindInput,
    ) -> Result<UnwindOutput, StageError> {
        match &self.source {
            None => Ok(UnwindOutput { checkpoint: input.checkpoint.with_block_number(input.unwind_to) }),
            Some(_) => todo!()
        }
    }
}
