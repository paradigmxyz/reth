use std::sync::mpsc;
use std::time::Duration;

use clap::Parser;
use reth_libmdbx::pageviz::{PageEvent, PageOp};

#[derive(Parser)]
#[command(name = "reth-mdbx-viz", about = "Real-time MDBX page visualization")]
struct Args {
    /// Path to the .bin owner map file (generated by mdbx-viz Python tool)
    #[arg(short, long)]
    bin: Option<String>,

    /// Page size in bytes
    #[arg(long, default_value = "4096")]
    page_size: u32,

    /// Port to serve on
    #[arg(short, long, default_value = "3141")]
    port: u16,

    /// Generate fake events for testing
    #[arg(long)]
    demo: bool,
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt()
        .with_env_filter(
            tracing_subscriber::EnvFilter::try_from_default_env()
                .unwrap_or_else(|_| "info".into()),
        )
        .init();

    let args = Args::parse();

    let (owner_map, page_count) = if let Some(ref bin_path) = args.bin {
        let data = std::fs::read(bin_path).expect("failed to read .bin file");
        let pc = data.len() as u64;
        tracing::info!("loaded owner map: {pc} pages from {bin_path}");
        (data, pc)
    } else {
        tracing::info!("no --bin provided, starting with empty owner map");
        (vec![0xFFu8; 1_000_000], 1_000_000)
    };

    let (tx, rx) = mpsc::channel();

    if args.demo {
        let np = page_count as u32;
        std::thread::Builder::new()
            .name("demo-events".into())
            .spawn(move || {
                let mut pgno: u32 = 0;
                loop {
                    let mut batch = Vec::with_capacity(256);
                    for _ in 0..256 {
                        let p = pgno % np;
                        batch.push(PageEvent {
                            pgno: p,
                            dbi: (p % 8) + 2,
                            op: match p % 10 {
                                0..=6 => PageOp::Read,
                                7..=8 => PageOp::Write,
                                _ => PageOp::Free,
                            },
                        });
                        pgno = pgno.wrapping_add(37);
                    }
                    if tx.send(batch).is_err() {
                        break;
                    }
                    std::thread::sleep(Duration::from_millis(33));
                }
            })
            .expect("failed to spawn demo thread");
    }

    let config = reth_mdbx_viz::VizConfig {
        port: args.port,
        page_count,
        page_size: args.page_size,
        dbi_names: vec![],
        tree_info: vec![],
        owner_map,
        db_path: std::path::PathBuf::new(),
    };

    if let Err(e) = reth_mdbx_viz::start_viz_server(config, rx).await {
        tracing::error!("server error: {e}");
    }
}
